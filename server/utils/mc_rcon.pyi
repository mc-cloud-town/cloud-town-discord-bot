from _typeshed import Incomplete
from asyncio import AbstractEventLoop, Protocol
from enum import Enum
from typing import TypeVar, TypedDict

T = TypeVar('T', bound='RconClientProtocol')
log: Incomplete

class RconPacketType(Enum):
    COMMAND_RESPONSE: int
    COMMAND_EXECUTE: int
    LOGIN: int

class RconPacketData(TypedDict):
    id: int
    type: int
    data: str

class ReconException(Exception): ...
class LoginError(ReconException): ...

class ConnectState(Enum):
    CONNECTING: Incomplete
    CONNECTED: Incomplete
    AUTHENTICATED: Incomplete
    CLOSED: Incomplete

class RconClientProtocol(Protocol):
    state: Incomplete
    _transport: Incomplete
    _loop: Incomplete
    _wait_read: Incomplete
    _lock: Incomplete
    timeout: Incomplete
    def __init__(self, loop: AbstractEventLoop | None = ..., command_timeout: int = ...) -> None: ...
    def __call__(self) -> T: ...
    def connection_made(self, transport) -> None: ...
    def data_received(self, data) -> None: ...
    def connection_lost(self, exc) -> None: ...
    def close(self) -> None: ...
    def is_connected(self) -> bool: ...
    async def _send(self, type: RconPacketType, data: str) -> RconPacketData: ...
    password: Incomplete
    async def authenticate(self, password: str) -> None: ...
    async def execute(self, command: str, *, timeout: float | None = ...) -> RconPacketData: ...

class RconClient:
    host: Incomplete
    port: Incomplete
    password: Incomplete
    loop: Incomplete
    protocol: Incomplete
    def __init__(self, host: str | None = ..., port: int | str | None = ..., password: str | None = ..., loop: AbstractEventLoop | None = ..., protocol: Protocol | None = ...) -> None: ...
    @property
    def is_connected(self): ...
    async def connect(self, *, exception: bool = ...) -> None: ...
    async def __aenter__(self) -> T: ...
    def disconnect(self) -> None: ...
    async def __aexit__(self, type, value, trace) -> None: ...
    def execute(self, command: str, *, timeout: float | None = ...): ...
